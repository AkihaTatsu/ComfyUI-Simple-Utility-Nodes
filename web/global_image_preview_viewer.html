<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Global Image Preview — Live Viewer</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg: #1a1a2e;
            --bg-panel: #16213e;
            --accent: #0f3460;
            --text: #e0e0e0;
            --text-dim: #8899aa;
            --border: #0f3460;
            --green: #4ecca3;
            --red: #e74c3c;
            --yellow: #f0c040;
            --orange: #e67e22;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ── Top bar ────────────────────────────────────────── */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            z-index: 10;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Left section: title + status */
        .top-left {
            display: flex;
            align-items: center;
            gap: 14px;
            min-width: 0;
        }
        .top-left h1 {
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 7px;
            white-space: nowrap;
        }

        /* Workflow status chip */
        .wf-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            padding: 3px 10px;
            border-radius: 12px;
            white-space: nowrap;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.04);
        }
        .wf-status .dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .wf-status.idle .dot    { background: var(--text-dim); }
        .wf-status.running .dot { background: var(--green); animation: pulse 1.2s infinite; }
        .wf-status.idle   { color: var(--text-dim); }
        .wf-status.running { color: var(--green); }
        .wf-node {
            max-width: 260px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Right section: controls */
        .top-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }
        .top-right label {
            font-size: 13px;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .top-right select {
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 13px;
        }
        .top-right button {
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        .top-right button:hover { background: #1a4a80; }
        .top-right button.active { background: var(--green); color: #111; }

        /* Rerun split-button group */
        .rerun-group {
            display: flex;
            align-items: stretch;
            border-radius: 4px;
            overflow: hidden;
        }
        #rerunBtn {
            background: var(--orange);
            color: #fff;
            border: 1px solid var(--orange);
            border-right: none;
            border-radius: 4px 0 0 4px;
            font-weight: 600;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        #rerunBtn:hover { background: #cf6d17; }
        #rerunBtn:disabled { opacity: 0.4; cursor: not-allowed; }
        #rerunMode {
            background: var(--orange);
            color: #fff;
            border: 1px solid var(--orange);
            border-left: 1px solid rgba(255,255,255,0.25);
            border-radius: 0 4px 4px 0;
            padding: 2px 2px;
            cursor: pointer;
            font-size: 12px;
            -webkit-appearance: none;
            appearance: none;
            min-width: 0;
            width: auto;
            padding: 2px 6px;
            outline: none;
        }
        #rerunMode:hover { background: #cf6d17; }
        #rerunMode option { background: var(--bg-panel); color: var(--text); }

        /* Interrupt button */
        #interruptBtn {
            background: var(--red);
            color: #fff;
            border: 1px solid var(--red);
            border-radius: 4px;
            font-weight: 600;
            padding: 4px 10px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
            line-height: 1.2;
        }
        #interruptBtn:hover { background: #c0392b; }
        #interruptBtn:disabled { opacity: 0.35; cursor: not-allowed; }

        /* Connection dot in title */
        .conn-dot {
            width: 9px; height: 9px;
            border-radius: 50%;
            background: var(--green);
            display: inline-block;
        }
        .conn-dot.disconnected { background: var(--red); }

        /* ── Image area ─────────────────────────────────────── */
        main {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: relative;
        }
        main.scrollable {
            overflow: auto;
        }

        #imageContainer {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        #previewImage {
            image-rendering: auto;
            /* default: no special sizing — applyFit() sets inline styles + class */
        }

        /*  Contain  — shrink if too big, otherwise stay at natural size, centered */
        #previewImage.fit-contain {
            max-width: 100%;
            max-height: 100%;
            width: auto;
            height: auto;
            object-fit: contain;
        }

        /*  Fill  — always stretch to fill viewport (no crop) */
        #previewImage.fit-fill {
            width: 100%;
            height: 100%;
            max-width: none;
            max-height: none;
            object-fit: contain;
        }

        /*  Actual Size  — natural size, scroll to view */
        #previewImage.fit-actual {
            max-width: none;
            max-height: none;
            width: auto;
            height: auto;
            object-fit: none;
            cursor: grab;
        }
        #previewImage.dragging { cursor: grabbing; }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: var(--text-dim);
        }
        .placeholder svg { opacity: 0.3; }
        .placeholder p { font-size: 14px; }

        /* ── Footer ─────────────────────────────────────────── */
        footer {
            padding: 4px 16px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-dim);
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
        }

        /* ── History sidebar ────────────────────────────────── */
        #historySidebar {
            position: absolute;
            top: 0; right: 0;
            width: 180px;
            height: 100%;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            display: none;
            flex-direction: column;
            z-index: 5;
        }
        #historySidebar.open { display: flex; }
        #historySidebar h3 {
            padding: 8px;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .history-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
        }
        .history-item {
            width: 100%;
            padding: 2px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
            margin-bottom: 4px;
        }
        .history-item.selected { border-color: var(--green); }
        .history-item img {
            width: 100%;
            height: auto;
            border-radius: 3px;
            display: block;
        }
    </style>
</head>
<body>

<!-- ── Top bar ── -->
<div class="top-bar">
    <div class="top-left">
        <h1>
            <span class="conn-dot" id="connDot"></span>
            ⛏️ Global Image Preview
        </h1>
        <div class="wf-status idle" id="wfStatus">
            <span class="dot"></span>
            <span id="wfLabel">Idle</span>
            <span class="wf-node" id="wfNode"></span>
        </div>
    </div>
    <div class="top-right">
        <button id="interruptBtn" disabled title="Interrupt the current running workflow">✕ Interrupt</button>
        <div class="rerun-group">
            <button id="rerunBtn" title="Interrupt (if running) and rerun the last workflow">⟳ Rerun (Same Task)</button>
            <select id="rerunMode" title="Choose rerun mode">
                <option value="same">▾ Same Task</option>
                <option value="new">▾ New Task</option>
            </select>
        </div>
        <label>
            Fit
            <select id="fitMode">
                <option value="contain">Contain</option>
                <option value="fill">Fill</option>
                <option value="actual">Actual Size</option>
            </select>
        </label>
        <button id="historyBtn" title="Toggle history panel">History</button>
    </div>
</div>

<main>
    <div id="imageContainer">
        <div class="placeholder" id="placeholder">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21 15 16 10 5 21"/>
            </svg>
            <p>Waiting for images…</p>
            <p style="font-size:12px">Run a workflow with preview / save image nodes</p>
        </div>
        <img id="previewImage" style="display:none;" alt="Preview"/>
    </div>
    <div id="historySidebar">
        <h3>History</h3>
        <div class="history-list" id="historyList"></div>
    </div>
</main>

<footer>
    <span id="infoLeft">No image</span>
    <span id="infoRight">Polling…</span>
</footer>

<script>
(function() {
    /* ── Elements ── */
    const img            = document.getElementById('previewImage');
    const placeholder    = document.getElementById('placeholder');
    const fitMode        = document.getElementById('fitMode');
    const historyBtn     = document.getElementById('historyBtn');
    const historySidebar  = document.getElementById('historySidebar');
    const historyList    = document.getElementById('historyList');
    const connDot        = document.getElementById('connDot');
    const infoLeft       = document.getElementById('infoLeft');
    const infoRight      = document.getElementById('infoRight');
    const wfStatus       = document.getElementById('wfStatus');
    const wfLabel        = document.getElementById('wfLabel');
    const wfNode         = document.getElementById('wfNode');
    const rerunBtn       = document.getElementById('rerunBtn');
    const interruptBtn   = document.getElementById('interruptBtn');

    /* ── State ── */
    let lastKey            = null;
    let history            = [];
    const MAX_HISTORY      = 50;
    let currentBlobUrl     = null;
    let lastImagesCounter  = -1;
    let lastPreviewCounter = -1;
    let isPolling          = true;

    /* ── Helpers ── */
    function viewUrl(info) {
        return `/view?filename=${encodeURIComponent(info.filename)}`
             + `&type=${encodeURIComponent(info.type)}`
             + `&subfolder=${encodeURIComponent(info.subfolder || '')}`;
    }

    function showImageFromUrl(url, label) {
        img.src = url;
        img.style.display = 'block';
        placeholder.style.display = 'none';
        infoLeft.textContent = label;
        infoRight.textContent = 'Updated: ' + new Date().toLocaleTimeString();
        applyFit();
    }

    function showExecutedImage(info) {
        const key = `${info.type}/${info.subfolder || ''}/${info.filename}`;
        if (key === lastKey) return;
        lastKey = key;
        showImageFromUrl(viewUrl(info) + '&t=' + Date.now(), `${info.filename}  (${info.type})`);
        addToHistory(info);
    }

    function showPreviewBlob(blob) {
        if (currentBlobUrl) URL.revokeObjectURL(currentBlobUrl);
        currentBlobUrl = URL.createObjectURL(blob);
        lastKey = null;
        showImageFromUrl(currentBlobUrl, 'KSampler step preview');
    }

    function applyFit() {
        const mode = fitMode.value;
        img.classList.remove('fit-contain', 'fit-fill', 'fit-actual');
        main.classList.remove('scrollable');

        if (mode === 'fill') {
            img.classList.add('fit-fill');
        } else if (mode === 'actual') {
            img.classList.add('fit-actual');
            main.classList.add('scrollable');
        } else {
            /* contain (default) — shrink-only */
            img.classList.add('fit-contain');
        }
    }

    /* ── History ── */
    function addToHistory(info) {
        if (history.length && history[history.length - 1].filename === info.filename
            && history[history.length - 1].type === info.type) return;
        history.push(info);
        if (history.length > MAX_HISTORY) history.shift();
        renderHistory();
    }

    function renderHistory() {
        historyList.innerHTML = '';
        for (let i = history.length - 1; i >= 0; i--) {
            const info = history[i];
            const div = document.createElement('div');
            div.className = 'history-item';
            const thumb = document.createElement('img');
            thumb.src = viewUrl(info) + '&preview=webp;60';
            thumb.loading = 'lazy';
            div.appendChild(thumb);
            div.addEventListener('click', () => {
                showImageFromUrl(viewUrl(info) + '&t=' + Date.now(), `${info.filename}  (${info.type})`);
            });
            historyList.appendChild(div);
        }
    }

    historyBtn.addEventListener('click', () => {
        historySidebar.classList.toggle('open');
        historyBtn.classList.toggle('active');
    });

    fitMode.addEventListener('change', applyFit);

    /* ── Drag-to-pan (Actual Size mode) ── */
    let isDragging = false, startX, startY, scrollL, scrollT;
    const main = document.querySelector('main');
    img.addEventListener('mousedown', (e) => {
        if (!img.classList.contains('fit-actual')) return;
        isDragging = true;
        img.classList.add('dragging');
        startX = e.clientX; startY = e.clientY;
        scrollL = main.scrollLeft; scrollT = main.scrollTop;
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        main.scrollLeft = scrollL - (e.clientX - startX);
        main.scrollTop  = scrollT - (e.clientY - startY);
    });
    document.addEventListener('mouseup', () => {
        isDragging = false;
        img.classList.remove('dragging');
    });

    /* ═══════════════════════════════════════════════════════
     * Workflow status display
     * ═══════════════════════════════════════════════════════ */
    function updateWorkflowStatus(status) {
        if (!status) return;
        const running = status.running;
        wfStatus.className = 'wf-status ' + (running ? 'running' : 'idle');

        if (running) {
            const nodeClass = status.current_node_class || '';
            const nodeId    = status.current_node_id || '';
            wfLabel.textContent = 'Running';
            if (nodeClass && nodeId !== '__starting__') {
                wfNode.textContent = `· #${nodeId} ${nodeClass}`;
            } else if (nodeId === '__starting__') {
                wfNode.textContent = '· Starting…';
            } else {
                wfNode.textContent = nodeId ? `· Node #${nodeId}` : '';
            }
        } else {
            wfLabel.textContent = 'Idle';
            wfNode.textContent = '';
        }

        // Check if our pending rerun has been confirmed by the server
        rerunCheckConfirmation(status);

        // Check if our pending interrupt has been confirmed by the server
        interruptCheckConfirmation(status);

        // Enable/disable interrupt button based on running state
        if (!_interruptLocked) {
            interruptBtn.disabled = !running;
        }
    }

    /* ═══════════════════════════════════════════════════════
     * Rerun split-button — fully server-driven
     *
     * Design principles:
     *   1. Every rerun command goes through the server-side
     *      POST /simple_utility/global_image_preview/rerun
     *      endpoint.  This works identically from LAN or WAN,
     *      regardless of whether the ComfyUI tab is open.
     *
     *   2. Each viewer tab has a unique TAB_ID (UUID).  The
     *      rerun request sends this as ``rerun_id``.  The
     *      server echoes back the last successfully queued
     *      ``rerun_id`` in the status response so the tab
     *      can confirm its own command was processed.
     *
     *   3. The server clears the pending queue before adding
     *      the new rerun item, so rapid clicks or retries
     *      NEVER stack extra jobs.
     *
     *   4. "Same Task" re-queues the exact same prompt with
     *      all values unchanged (seeds, primitives, etc.).
     *      "New Task" applies each widget's
     *      control_after_generate rule (randomize/increment/
     *      decrement/fixed) server-side.
     *
     *   5. The button stays locked until the server confirms
     *      the rerun_id matches, OR a timeout expires.
     * ═══════════════════════════════════════════════════════ */
    const rerunMode   = document.getElementById('rerunMode');

    // Unique per-tab identifier — survives page reloads within the same tab
    const TAB_ID = crypto.randomUUID();

    // Button labels
    const LABELS = { same: '⟳ Rerun (Same Task)', new: '⟳ Rerun (New Task)' };
    function getMode() { return rerunMode.value || 'same'; }

    // ── Rerun state ──
    let _rerunLocked      = false;   // true while a rerun is in-flight
    let _pendingRerunId   = null;    // the rerun_id we are waiting for
    let _rerunTimeoutTimer = null;   // safety timeout to unlock the button
    const RERUN_TIMEOUT_MS = 15000;  // max wait before force-unlock

    // Sync button label with dropdown
    rerunMode.addEventListener('change', () => {
        if (!_rerunLocked) rerunBtn.textContent = LABELS[getMode()] || LABELS.same;
    });

    /**
     * Called every poll cycle (from updateWorkflowStatus).
     * Checks if the server's last_rerun_id matches the one we sent.
     */
    function rerunCheckConfirmation(status) {
        if (!_rerunLocked || !_pendingRerunId) return;
        if (status && status.last_rerun_id === _pendingRerunId) {
            rerunUnlock();
        }
    }

    /** Unlock the button and reset all rerun state. */
    function rerunUnlock() {
        clearTimeout(_rerunTimeoutTimer);
        _rerunTimeoutTimer = null;
        _rerunLocked    = false;
        _pendingRerunId = null;
        rerunBtn.disabled = false;
        rerunBtn.textContent = LABELS[getMode()] || LABELS.same;
    }

    /** Main click handler. */
    rerunBtn.addEventListener('click', async () => {
        if (_rerunLocked) return;

        // Lock immediately
        _rerunLocked  = true;
        rerunBtn.disabled = true;
        rerunBtn.textContent = '⟳ Sending…';

        // Generate a unique ID for THIS specific rerun request
        const rerunId = TAB_ID + ':' + Date.now();
        _pendingRerunId = rerunId;

        // Safety timeout — always unlock after RERUN_TIMEOUT_MS
        _rerunTimeoutTimer = setTimeout(() => {
            console.warn('Rerun: timed out waiting for server confirmation');
            rerunUnlock();
        }, RERUN_TIMEOUT_MS);

        // Send the rerun command to the server
        try {
            const resp = await fetch('/simple_utility/global_image_preview/rerun', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    mode: getMode(),
                    rerun_id: rerunId,
                }),
            });

            if (!resp.ok) {
                const data = await resp.json().catch(() => ({}));
                console.warn('Rerun failed:', data.error || resp.statusText);
                rerunUnlock();
                return;
            }

            // Server accepted — now wait for poll loop to confirm
            rerunBtn.textContent = '⟳ Waiting…';
        } catch (e) {
            console.warn('Rerun request error:', e);
            rerunUnlock();
        }
    });

    /* ═══════════════════════════════════════════════════════
     * Interrupt button
     *
     * Sends POST /simple_utility/global_image_preview/interrupt
     * with a unique interrupt_id.  The button stays locked
     * until the server echoes back the same interrupt_id in
     * the status response (confirming the interrupt was
     * processed), OR a safety timeout expires.
     * ═══════════════════════════════════════════════════════ */
    let _interruptLocked       = false;
    let _pendingInterruptId    = null;
    let _interruptTimeoutTimer = null;
    const INTERRUPT_TIMEOUT_MS = 10000;

    function interruptCheckConfirmation(status) {
        if (!_interruptLocked || !_pendingInterruptId) return;
        if (status && status.last_interrupt_id === _pendingInterruptId) {
            interruptUnlock();
        }
    }

    function interruptUnlock() {
        clearTimeout(_interruptTimeoutTimer);
        _interruptTimeoutTimer = null;
        _interruptLocked    = false;
        _pendingInterruptId = null;
        interruptBtn.textContent = '✕ Interrupt';
        // Will be re-enabled/disabled by next status poll based on running state
        interruptBtn.disabled = true;
    }

    interruptBtn.addEventListener('click', async () => {
        if (_interruptLocked) return;

        _interruptLocked = true;
        interruptBtn.disabled = true;
        interruptBtn.textContent = '✕ Interrupting…';

        const interruptId = TAB_ID + ':int:' + Date.now();
        _pendingInterruptId = interruptId;

        _interruptTimeoutTimer = setTimeout(() => {
            console.warn('Interrupt: timed out waiting for server confirmation');
            interruptUnlock();
        }, INTERRUPT_TIMEOUT_MS);

        try {
            const resp = await fetch('/simple_utility/global_image_preview/interrupt', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ interrupt_id: interruptId }),
            });
            if (!resp.ok) {
                console.warn('Interrupt failed:', resp.statusText);
                interruptUnlock();
            }
            // Wait for poll loop to confirm via last_interrupt_id
        } catch (e) {
            console.warn('Interrupt request error:', e);
            interruptUnlock();
        }
    });

    /* ═══════════════════════════════════════════════════════
     * HTTP polling
     * ═══════════════════════════════════════════════════════ */
    async function pollLoop() {
        while (isPolling) {
            try {
                // Fetch image + preview counters
                const resp = await fetch('/simple_utility/global_image_preview/latest');
                if (resp.ok) {
                    connDot.classList.remove('disconnected');
                    const data = await resp.json();

                    const imagesCounter = data.images_counter ?? -1;
                    if (imagesCounter !== lastImagesCounter && imagesCounter > 0) {
                        lastImagesCounter = imagesCounter;
                        const images = data.images || [];
                        if (images.length > 0) {
                            showExecutedImage(images[images.length - 1]);
                        }
                    }

                    const previewCounter = data.preview_counter ?? -1;
                    if (previewCounter !== lastPreviewCounter && previewCounter > 0) {
                        lastPreviewCounter = previewCounter;
                        if (data.has_preview_blob) {
                            try {
                                const previewResp = await fetch(
                                    '/simple_utility/global_image_preview/latest_preview'
                                );
                                if (previewResp.ok) {
                                    const blob = await previewResp.blob();
                                    showPreviewBlob(blob);
                                }
                            } catch(e) { /* ignore */ }
                        }
                    }
                } else {
                    connDot.classList.add('disconnected');
                }

                // Fetch workflow status
                try {
                    const sr = await fetch('/simple_utility/global_image_preview/status');
                    if (sr.ok) updateWorkflowStatus(await sr.json());
                } catch(e) {}
            } catch(e) {
                connDot.classList.add('disconnected');
            }

            await new Promise(r => setTimeout(r, 300));
        }
    }

    /* ── Init ── */
    connDot.classList.add('disconnected');   // start as red until first successful poll
    pollLoop();
})();
</script>
</body>
</html>
