<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>⛏️ Simple Global Image Preview — Live Viewer</title>
    <style>
        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

        :root {
            --bg: #1a1a2e;
            --bg-panel: #16213e;
            --accent: #0f3460;
            --text: #e0e0e0;
            --text-dim: #8899aa;
            --border: #0f3460;
            --green: #4ecca3;
            --red: #e74c3c;
            --yellow: #f0c040;
            --orange: #e67e22;
        }

        body {
            background: var(--bg);
            color: var(--text);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        /* ── Top bar ────────────────────────────────────────── */
        .top-bar {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 6px 16px;
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
            z-index: 10;
            gap: 12px;
            flex-wrap: wrap;
        }

        /* Left section: title + status */
        .top-left {
            display: flex;
            align-items: center;
            gap: 14px;
            min-width: 0;
        }
        .top-left h1 {
            font-size: 15px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 7px;
            white-space: nowrap;
        }

        /* Workflow status chip */
        .wf-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            padding: 3px 10px;
            border-radius: 12px;
            white-space: nowrap;
            border: 1px solid var(--border);
            background: rgba(255,255,255,0.04);
        }
        .wf-status .dot {
            width: 8px; height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        .wf-status.idle .dot    { background: var(--text-dim); }
        .wf-status.running .dot { background: var(--green); animation: pulse 1.2s infinite; }
        .wf-status.idle   { color: var(--text-dim); }
        .wf-status.running { color: var(--green); }
        .wf-node {
            max-width: 260px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Right section: controls */
        .top-right {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }
        .top-right label {
            font-size: 13px;
            color: var(--text-dim);
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .top-right select {
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 3px 6px;
            font-size: 13px;
        }
        .top-right button {
            background: var(--accent);
            color: var(--text);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        .top-right button:hover { background: #1a4a80; }
        .top-right button.active { background: var(--green); color: #111; }

        /* Rerun split-button group */
        .rerun-group {
            display: flex;
            align-items: stretch;
            border-radius: 4px;
            overflow: hidden;
        }
        #rerunBtn {
            background: var(--orange);
            color: #fff;
            border: 1px solid var(--orange);
            border-right: none;
            border-radius: 4px 0 0 4px;
            font-weight: 600;
            padding: 4px 12px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }
        #rerunBtn:hover { background: #cf6d17; }
        #rerunBtn:disabled { opacity: 0.4; cursor: not-allowed; }
        #rerunMode {
            background: var(--orange);
            color: #fff;
            border: 1px solid var(--orange);
            border-left: 1px solid rgba(255,255,255,0.25);
            border-radius: 0 4px 4px 0;
            padding: 2px 2px;
            cursor: pointer;
            font-size: 12px;
            -webkit-appearance: none;
            appearance: none;
            min-width: 0;
            width: auto;
            padding: 2px 6px;
            outline: none;
        }
        #rerunMode:hover { background: #cf6d17; }
        #rerunMode option { background: var(--bg-panel); color: var(--text); }

        /* Connection dot in title */
        .conn-dot {
            width: 9px; height: 9px;
            border-radius: 50%;
            background: var(--green);
            display: inline-block;
        }
        .conn-dot.disconnected { background: var(--red); }

        /* ── Image area ─────────────────────────────────────── */
        main {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: auto;
            position: relative;
        }

        #imageContainer {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
        }

        #previewImage {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            image-rendering: auto;
        }
        #previewImage.cover  { object-fit: cover; }
        #previewImage.actual {
            max-width: none;
            max-height: none;
            object-fit: none;
            cursor: grab;
        }
        #previewImage.dragging { cursor: grabbing; }

        .placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 12px;
            color: var(--text-dim);
        }
        .placeholder svg { opacity: 0.3; }
        .placeholder p { font-size: 14px; }

        /* ── Footer ─────────────────────────────────────────── */
        footer {
            padding: 4px 16px;
            background: var(--bg-panel);
            border-top: 1px solid var(--border);
            font-size: 12px;
            color: var(--text-dim);
            display: flex;
            justify-content: space-between;
            flex-shrink: 0;
        }

        /* ── History sidebar ────────────────────────────────── */
        #historySidebar {
            position: absolute;
            top: 0; right: 0;
            width: 180px;
            height: 100%;
            background: var(--bg-panel);
            border-left: 1px solid var(--border);
            overflow-y: auto;
            display: none;
            flex-direction: column;
            z-index: 5;
        }
        #historySidebar.open { display: flex; }
        #historySidebar h3 {
            padding: 8px;
            font-size: 13px;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }
        .history-list {
            flex: 1;
            overflow-y: auto;
            padding: 4px;
        }
        .history-item {
            width: 100%;
            padding: 2px;
            cursor: pointer;
            border: 2px solid transparent;
            border-radius: 4px;
            margin-bottom: 4px;
        }
        .history-item.selected { border-color: var(--green); }
        .history-item img {
            width: 100%;
            height: auto;
            border-radius: 3px;
            display: block;
        }
    </style>
</head>
<body>

<!-- ── Top bar ── -->
<div class="top-bar">
    <div class="top-left">
        <h1>
            <span class="conn-dot" id="connDot"></span>
            ⛏️ Global Image Preview
        </h1>
        <div class="wf-status idle" id="wfStatus">
            <span class="dot"></span>
            <span id="wfLabel">Idle</span>
            <span class="wf-node" id="wfNode"></span>
        </div>
    </div>
    <div class="top-right">
        <div class="rerun-group">
            <button id="rerunBtn" title="Interrupt (if running) and rerun the last workflow">⟳ Rerun (Same Task)</button>
            <select id="rerunMode" title="Choose rerun mode">
                <option value="same">▾ Same Task</option>
                <option value="new">▾ New Task</option>
            </select>
        </div>
        <label>
            Fit
            <select id="fitMode">
                <option value="contain">Contain</option>
                <option value="cover">Cover</option>
                <option value="actual">Actual Size</option>
            </select>
        </label>
        <button id="historyBtn" title="Toggle history panel">History</button>
    </div>
</div>

<main>
    <div id="imageContainer">
        <div class="placeholder" id="placeholder">
            <svg width="64" height="64" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5">
                <rect x="3" y="3" width="18" height="18" rx="2"/>
                <circle cx="8.5" cy="8.5" r="1.5"/>
                <polyline points="21 15 16 10 5 21"/>
            </svg>
            <p>Waiting for images…</p>
            <p style="font-size:12px">Run a workflow with preview / save image nodes</p>
        </div>
        <img id="previewImage" style="display:none;" alt="Preview"/>
    </div>
    <div id="historySidebar">
        <h3>History</h3>
        <div class="history-list" id="historyList"></div>
    </div>
</main>

<footer>
    <span id="infoLeft">No image</span>
    <span id="infoRight">Polling…</span>
</footer>

<script>
(function() {
    /* ── Elements ── */
    const img            = document.getElementById('previewImage');
    const placeholder    = document.getElementById('placeholder');
    const fitMode        = document.getElementById('fitMode');
    const historyBtn     = document.getElementById('historyBtn');
    const historySidebar  = document.getElementById('historySidebar');
    const historyList    = document.getElementById('historyList');
    const connDot        = document.getElementById('connDot');
    const infoLeft       = document.getElementById('infoLeft');
    const infoRight      = document.getElementById('infoRight');
    const wfStatus       = document.getElementById('wfStatus');
    const wfLabel        = document.getElementById('wfLabel');
    const wfNode         = document.getElementById('wfNode');
    const rerunBtn       = document.getElementById('rerunBtn');

    /* ── State ── */
    let lastKey            = null;
    let history            = [];
    const MAX_HISTORY      = 50;
    let currentBlobUrl     = null;
    let lastImagesCounter  = -1;
    let lastPreviewCounter = -1;
    let isPolling          = true;
    let rerunInFlight      = false;

    /* ── Helpers ── */
    function viewUrl(info) {
        return `/view?filename=${encodeURIComponent(info.filename)}`
             + `&type=${encodeURIComponent(info.type)}`
             + `&subfolder=${encodeURIComponent(info.subfolder || '')}`;
    }

    function showImageFromUrl(url, label) {
        img.src = url;
        img.style.display = 'block';
        placeholder.style.display = 'none';
        infoLeft.textContent = label;
        infoRight.textContent = 'Updated: ' + new Date().toLocaleTimeString();
        applyFit();
    }

    function showExecutedImage(info) {
        const key = `${info.type}/${info.subfolder || ''}/${info.filename}`;
        if (key === lastKey) return;
        lastKey = key;
        showImageFromUrl(viewUrl(info) + '&t=' + Date.now(), `${info.filename}  (${info.type})`);
        addToHistory(info);
    }

    function showPreviewBlob(blob) {
        if (currentBlobUrl) URL.revokeObjectURL(currentBlobUrl);
        currentBlobUrl = URL.createObjectURL(blob);
        lastKey = null;
        showImageFromUrl(currentBlobUrl, 'KSampler step preview');
    }

    function applyFit() {
        const mode = fitMode.value;
        img.classList.remove('cover', 'actual');
        if (mode === 'cover')       img.classList.add('cover');
        else if (mode === 'actual') img.classList.add('actual');
    }

    /* ── History ── */
    function addToHistory(info) {
        if (history.length && history[history.length - 1].filename === info.filename
            && history[history.length - 1].type === info.type) return;
        history.push(info);
        if (history.length > MAX_HISTORY) history.shift();
        renderHistory();
    }

    function renderHistory() {
        historyList.innerHTML = '';
        for (let i = history.length - 1; i >= 0; i--) {
            const info = history[i];
            const div = document.createElement('div');
            div.className = 'history-item';
            const thumb = document.createElement('img');
            thumb.src = viewUrl(info) + '&preview=webp;60';
            thumb.loading = 'lazy';
            div.appendChild(thumb);
            div.addEventListener('click', () => {
                showImageFromUrl(viewUrl(info) + '&t=' + Date.now(), `${info.filename}  (${info.type})`);
            });
            historyList.appendChild(div);
        }
    }

    historyBtn.addEventListener('click', () => {
        historySidebar.classList.toggle('open');
        historyBtn.classList.toggle('active');
    });

    fitMode.addEventListener('change', applyFit);

    /* ── Drag-to-pan (Actual Size mode) ── */
    let isDragging = false, startX, startY, scrollL, scrollT;
    const main = document.querySelector('main');
    img.addEventListener('mousedown', (e) => {
        if (!img.classList.contains('actual')) return;
        isDragging = true;
        img.classList.add('dragging');
        startX = e.clientX; startY = e.clientY;
        scrollL = main.scrollLeft; scrollT = main.scrollTop;
        e.preventDefault();
    });
    document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        main.scrollLeft = scrollL - (e.clientX - startX);
        main.scrollTop  = scrollT - (e.clientY - startY);
    });
    document.addEventListener('mouseup', () => {
        isDragging = false;
        img.classList.remove('dragging');
    });

    /* ═══════════════════════════════════════════════════════
     * Workflow status display
     * ═══════════════════════════════════════════════════════ */
    function updateWorkflowStatus(status) {
        if (!status) return;
        const running = status.running;
        wfStatus.className = 'wf-status ' + (running ? 'running' : 'idle');

        if (running) {
            const nodeClass = status.current_node_class || '';
            const nodeId    = status.current_node_id || '';
            wfLabel.textContent = 'Running';
            if (nodeClass && nodeId !== '__starting__') {
                wfNode.textContent = `· #${nodeId} ${nodeClass}`;
            } else if (nodeId === '__starting__') {
                wfNode.textContent = '· Starting…';
            } else {
                wfNode.textContent = nodeId ? `· Node #${nodeId}` : '';
            }
        } else {
            wfLabel.textContent = 'Idle';
            wfNode.textContent = '';
        }

        rerunBtn.disabled = rerunInFlight;
    }

    /* ═══════════════════════════════════════════════════════
     * Rerun split-button
     *
     * Two modes controlled by the dropdown:
     *   "same" — Same Task: POST /rerun with the exact captured prompt
     *            (seeds stay the same, everything identical)
     *   "new"  — New Task: send a BroadcastChannel message to the
     *            main ComfyUI tab which calls app.queuePrompt(0),
     *            re-serializing the graph (seed++, etc.)
     * ═══════════════════════════════════════════════════════ */
    const rerunMode = document.getElementById('rerunMode');
    let bc = null;
    try { bc = new BroadcastChannel('simple_global_image_preview'); } catch(e) {}

    // Update button label when mode changes
    const LABELS = { same: '⟳ Rerun (Same Task)', new: '⟳ Rerun (New Task)' };
    function getMode() {
        return rerunMode.value || 'same';
    }
    rerunMode.addEventListener('change', () => {
        if (!rerunInFlight) rerunBtn.textContent = LABELS[getMode()] || LABELS.same;
    });

    // Listen for ack from main tab (New Task mode)
    if (bc) {
        bc.onmessage = (ev) => {
            if (ev.data?.type === 'rerun_new_task_ack') {
                if (!ev.data.ok) console.warn('New Task rerun failed:', ev.data.error);
                finishRerun();
            }
        };
    }

    function finishRerun() {
        setTimeout(() => {
            rerunInFlight = false;
            rerunBtn.disabled = false;
            rerunBtn.textContent = LABELS[getMode()] || LABELS.same;
        }, 600);
    }

    rerunBtn.addEventListener('click', async () => {
        if (rerunInFlight) return;
        rerunInFlight = true;
        rerunBtn.disabled = true;
        rerunBtn.textContent = '⟳ Rerunning…';

        const mode = getMode();

        if (mode === 'new') {
            /* ── New Task: ask the main ComfyUI tab via BroadcastChannel ── */
            if (!bc) {
                console.warn('BroadcastChannel not available');
                finishRerun();
                return;
            }
            // Check if workflow is running → need to interrupt first
            let running = false;
            try {
                const sr = await fetch('/simple_utility/global_image_preview/status');
                if (sr.ok) { running = (await sr.json()).running; }
            } catch(e) {}
            bc.postMessage({ type: 'rerun_new_task', interrupt: running });
            // finishRerun() will be called when we receive the ack
            // Timeout fallback in case main tab is not open
            setTimeout(() => { if (rerunInFlight) finishRerun(); }, 5000);
        } else {
            /* ── Same Task: POST to server /rerun endpoint ── */
            try {
                const resp = await fetch('/simple_utility/global_image_preview/rerun', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: '{}',
                });
                const data = await resp.json();
                if (!resp.ok) console.warn('Rerun failed:', data.error);
            } catch(e) {
                console.warn('Rerun request error:', e);
            }
            finishRerun();
        }
    });

    /* ═══════════════════════════════════════════════════════
     * HTTP polling
     * ═══════════════════════════════════════════════════════ */
    async function pollLoop() {
        while (isPolling) {
            try {
                // Fetch image + preview counters
                const resp = await fetch('/simple_utility/global_image_preview/latest');
                if (resp.ok) {
                    connDot.classList.remove('disconnected');
                    const data = await resp.json();

                    const imagesCounter = data.images_counter ?? -1;
                    if (imagesCounter !== lastImagesCounter && imagesCounter > 0) {
                        lastImagesCounter = imagesCounter;
                        const images = data.images || [];
                        if (images.length > 0) {
                            showExecutedImage(images[images.length - 1]);
                        }
                    }

                    const previewCounter = data.preview_counter ?? -1;
                    if (previewCounter !== lastPreviewCounter && previewCounter > 0) {
                        lastPreviewCounter = previewCounter;
                        if (data.has_preview_blob) {
                            try {
                                const previewResp = await fetch(
                                    '/simple_utility/global_image_preview/latest_preview'
                                );
                                if (previewResp.ok) {
                                    const blob = await previewResp.blob();
                                    showPreviewBlob(blob);
                                }
                            } catch(e) { /* ignore */ }
                        }
                    }
                } else {
                    connDot.classList.add('disconnected');
                }

                // Fetch workflow status
                try {
                    const sr = await fetch('/simple_utility/global_image_preview/status');
                    if (sr.ok) updateWorkflowStatus(await sr.json());
                } catch(e) {}
            } catch(e) {
                connDot.classList.add('disconnected');
            }

            await new Promise(r => setTimeout(r, 300));
        }
    }

    /* ── Init ── */
    connDot.classList.remove('disconnected');
    pollLoop();
})();
</script>
</body>
</html>
